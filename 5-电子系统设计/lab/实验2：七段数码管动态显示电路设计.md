# 实验2：七段数码管动态显示电路设计

<p align="center">林莉淇    PB22051128</p>

## **一、实验内容**

​	首先编写 Verilog 程序，实现七段数码管动态显示控制电路（原理如下图），再编写Test Bench程序并完成功能仿真。接着查看 RTL 电路结构图、为设计工程分配管脚，最后完成硬件验证。

<img src="C:\Users\ASUS\AppData\Local\Temp\QQ_1729304800901.png" alt="QQ_1729304800901" style="zoom:67%;" />

<img src="C:\Users\ASUS\AppData\Local\Temp\QQ_1729304814941.png" alt="QQ_1729304814941" style="zoom:50%;" />

综合起来，总的框图为：

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20241019102841862.png" alt="image-20241019102841862" style="zoom: 33%;" />

## **二、设计分析**

​	需要针对锁存器、3-8译码器、4-7译码器、8选1选择器、分频器编写不同模块。思路上，先将3-8译码器与8个4位锁存器相连，再用八选一选择器对锁存器做出选择。其中，选择器的选择信号由clk经过分频器和计数器给出。之后，把选择得到的输出接到4-7译码器上，得到段码信号。此外，计数器的输出经过3-8译码器，得到位选信号。

​	具体模块如下：

+ 锁存器

  - 输入：使能信号en、片选信号cs、数据D；
  - 输出：数据Q；

+ 3-8译码器

  + 输入：二进制数A；

  + 输出：译码结果Y；

+ 8选1数据选择器

  + 输入：8个数据A,B,C,D,E,F,G,H、选择信号select；

  + 输出：选择结果Q；

+ 7段数码管

  + 输入：4位二进制信号q;
  + 输出：段码信号A,B,C,D,E,F,G;

+ 分频器

  + 输入：原始时钟clk、复位信号RST;
  + 输出：分频后clkD;

## 三、Verilog源代码

<p align="center">4位锁存器</p>

```verilog
module latch4_llq(D,en,cs,Q);
	input en,cs;
	input [3:0] D;
	output [3:0] Q;
	
	reg [3:0] Q;
	
	always @ (*)
	begin
		if(cs == 1)
			if(en == 1)
				Q <= D;
			else
				Q <= Q;
		else
			Q <= Q;
	end
endmodule
```

<p align="center">3-8译码器</p>

```verilog
module decoder3to8_llq(A,Y);
	input [2:0] A;
	output [7:0] Y;
	reg [7:0] Y;
	always @(A)
	begin
		case (A)
			3'b000: Y = 8'b00000001;
			3'b001: Y = 8'b00000010;
			3'b010: Y = 8'b00000100;
			3'b011: Y = 8'b00001000;
			3'b100: Y = 8'b00010000;
			3'b101: Y = 8'b00100000;
			3'b110: Y = 8'b01000000;
			3'b111: Y = 8'b10000000;
		endcase
	end
endmodule
```

<p align="center">8选1数据选择器</p>

```verilog
module select8to1_llq(A,B,C,D,E,F,G,H,select,Q);
	input [3:0] A,B,C,D,E,F,G,H;
	input [2:0] select;
	output [3:0] Q;
	reg [3:0] Q;
	always @(A or B or C or D or E or F or G or H or select)
		begin
			case (select)
				3'b000: Q <= A;
				3'b001: Q <= B;
				3'b010: Q <= C;
				3'b011: Q <= D;
				3'b100: Q <= E;
				3'b101: Q <= F;
				3'b110: Q <= G;
				3'b111: Q <= H;
				default: Q <= A;
			endcase
		end
endmodule
```

<p align="center">锁存器、3-8译码器、8选一数据选择器综合模块（待仿真模块）</p>

``` verilog
module func_llq(select,count,data,en,Q);
	input [2:0] select;
	input [2:0] count;
	input [3:0] data; 
	input en;   
	wire [3:0] Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7;
	wire [7:0] CS;  
	output [3:0] Q;      

	decoder3to8_llq Decoder(.A(select),.Y(CS));
	latch4_llq LATCH0(.en(en),.D(data),.Q(Q0),.cs(CS[0]));
	latch4_llq LATCH1(.en(en),.D(data),.Q(Q1),.cs(CS[1]));
	latch4_llq LATCH2(.en(en),.D(data),.Q(Q2),.cs(CS[2]));
	latch4_llq LATCH3(.en(en),.D(data),.Q(Q3),.cs(CS[3]));
	latch4_llq LATCH4(.en(en),.D(data),.Q(Q4),.cs(CS[4]));
	latch4_llq LATCH5(.en(en),.D(data),.Q(Q5),.cs(CS[5]));
	latch4_llq LATCH6(.en(en),.D(data),.Q(Q6),.cs(CS[6]));
	latch4_llq LATCH7(.en(en),.D(data),.Q(Q7),.cs(CS[7]));
	
	select8to1_llq MUX(.A(Q0),.B(Q1),.C(Q2),.D(Q3),.E(Q4),.F(Q5),.G(Q6),.H(Q7),.select(count),.Q(Q)); 
	
endmodule
```

<p align="center">7段数码管</p>

``` verilog
module Seg7Led(q,A,B,C,D,E,F,G);
	input [3:0] q;
	output A,B,C,D,E,F,G;
	reg [6:0] ATOG;
	always@(q)
		begin
			ATOG = 7'b0000000;
			case(q)
				4'b0000:ATOG = 7'b0000001;
				4'b0001:ATOG = 7'b1001111;
				4'b0010:ATOG = 7'b0010010;
				4'b0011:ATOG = 7'b0000110;
				4'b0100:ATOG = 7'b1001100;
				4'b0101:ATOG = 7'b0100100;
				4'b0110:ATOG = 7'b0100000;
				4'b0111:ATOG = 7'b0001111;
				4'b1000:ATOG = 7'b0000000;
				4'b1001:ATOG = 7'b0001000;
				4'b1010:ATOG = 7'b0001000;
				4'b1011:ATOG = 7'b1100000;
				4'b1100:ATOG = 7'b0110001;
				4'b1101:ATOG = 7'b1000010;
				4'b1110:ATOG = 7'b0110000;
				4'b1111:ATOG = 7'b0111000;
				default:ATOG = 7'b1111111;
			endcase
		end
		
		assign A = ATOG[6];
		assign B = ATOG[5];
		assign C = ATOG[4];
		assign D = ATOG[3];
		assign E = ATOG[2];
		assign F = ATOG[1];
		assign G = ATOG[0];
		
endmodule
```

<p align="center">分频器</p>

``` verilog
module FD(clk,clkD,RST);
	input clk;
	input RST;
	output clkD;
	reg [17:0] cnt = 0;
	reg clkD;
	always @(posedge clk) begin
		if(RST == 1'b0) begin
			cnt <= 18'd0;
			clkD <=0;
		end
		if(cnt==18'd2) begin 
			cnt <=18'b000000000000000000;
			clkD <=~clkD;
		end
		else begin
			cnt <=cnt+1;
		end
	end
endmodule
```

<p align="center">顶层函数</p>

``` verilog
module FPGA_EXP2_llq(en,data,select,clk,LED_S,A,B,C,D,E,F,G,RST);
	input clk,en,RST;
	input [2:0] select;
	input [3:0] data;
	wire clkD;
	reg [2:0] count;
	output [7:0] LED_S;
	output A,B,C,D,E,F,G;
	
	wire [3:0] Q;
	
	FD FD(clk,clkD,RST);
	
	always@(posedge clkD) begin
		count = count+1;
	end
 
	decoder3to8_llq Decoder(.A(count),.Y(LED_S));
	func_llq func(select,count,data,en,Q);
	Seg7Led Seg7Led(Q,A,B,C,D,E,F,G);
	
endmodule
```

<p align="center">仿真代码</p>

``` verilog
`timescale 10ns/1ns
module func_llq_tb();
	reg [2:0] select,count;
	reg [3:0] data; 
	reg en;
	wire [3:0] Q;
	
	initial begin
		#0 en=1'b1;
	end
	
	always begin
		#0 select=3'b000; 
		#2 select=3'b001;
		#2 select=3'b010;
		#2 select=3'b011;
		#2 select=3'b100;
		#2 select=3'b101;
		#2 select=3'b110;
		#2 select=3'b111;
	end
		
	always begin
		#0 data=4'b0000; 
		#2 data=4'b0001;
		#2 data=4'b0010;
		#2 data=4'b0011;
	end
		
	func_llq U1(select,select, data, en, Q);
	
endmodule
```

​	仿真了func模块，即包含8个4位锁存器、3-8译码器、8选一数据选择器的综合模块（实验内容框图中虚线框内部分）。

+ 使能信号en一直为1；
+ 为了便于仿真，令8选一数据选择器的count和3-8译码器的select一同变化（在顶层函数调用该模块时，会将数据选择器的count接到分频器上而不是select上，此处仅为了便于仿真）。

## 四、仿真结果记录

<img src="C:\Users\ASUS\Desktop\7e345391ef4ac94f3aeaac155b7a28ac.png" alt="7e345391ef4ac94f3aeaac155b7a28ac" style="zoom: 33%;" />

​	由图可见：

+ select=0，此时data=0，存入寄存器0
+ select=1，此时data=1，存入寄存器1
+ select=2，此时data=2，存入寄存器2
+ select=3，此时data=0，存入寄存器3
+ ……

​	可以看出，在使能信号en一直为1后，select信号使不同的data数据传入到不同的锁存器中。同时，count接到select上，使得8选一选择器选择的锁存器与select选择的相同，令data的改变能反馈到Q上。

## 五、RTL结构图

<p align="center">总程序</p>

<img src="C:/Users/ASUS/Documents/Tencent Files/1654875600/nt_qq/nt_data/Pic/2024-10/Thumb/7218d73ef4fad7bf71cbf21af41667ee_720.png" alt="7218d73ef4fad7bf71cbf21af41667ee_720" style="zoom:33%;" />

<p align="center">分频器</p>

<img src="C:/Users/ASUS/Documents/Tencent Files/1654875600/nt_qq/nt_data/Pic/2024-10/Ori/393b3bfea05321a4c1ea46c1bb2a5434.png" alt="393b3bfea05321a4c1ea46c1bb2a5434" style="zoom:33%;" />

<p align="center">仿真模块</p>

<img src="C:/Users/ASUS/Documents/Tencent Files/1654875600/nt_qq/nt_data/Pic/2024-10/Thumb/c9af0fb40acadb12dfdb1aae7c44d595_720.png" alt="c9af0fb40acadb12dfdb1aae7c44d595_720" style="zoom:33%;" />

​	如图，select接到decoder3to8_llq上，count接到select8to1_llq上，en接到每一个锁存器上。

<p align="center">7段数码管</p>

<img src="C:/Users/ASUS/Documents/Tencent Files/1654875600/nt_qq/nt_data/Pic/2024-10/Ori/5541af59708a6a10adde9610d9a10801.png" alt="5541af59708a6a10adde9610d9a10801" style="zoom: 25%;" />



## 六、FPGA验证结果记录

<p align="center">管脚锁定情况</p>

<img src="C:/Users/ASUS/AppData/Local/Temp/QQ_1729308202511.png" alt="QQ_1729308202511" style="zoom:50%;" />

​	动态结果的文字描述：先拨动DIP15复位。拨动DIP4使能后，拨动DIP5、DIP6、DIP7选定想要改变的锁存器，再拨动DIP0、DIP1、DIP2、DIP3，改变数字。

​	例如，当DIP0、1、2、3、4、5、6、7分别为0001  1  010时，从右往左第三个数码管显示的数字为1。此时再把DIP5、6、7调整为001，把DIP0、1、2、3调整为0、1、0、0，则第二个数码管显示4，同时第三个数码管依然显示1。

## 七、实验总结

​	通过这次实验，我明白了分模块调用的重要性。针对不同器件写不同模块再进行调用，可以使代码结构更加清晰。

​	其中，我碰到编译时报错"端口未定义"的情况，module内定义的所有输入输出端口都要写入module后面的括号声明中。

​	我还碰到分频器没有加复位信号，模块中各个变量没有赋初值的情况。

​	在这次实验中，我收获良多。下次实验会提前写好程序，成功编译、仿真，在实验室再进行最后的接线验证。